"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@xhmm/utils");
const CQHelper_1 = require("./CQHelper");
const logger_1 = require("./logger");
var Scope;
(function (Scope) {
    Scope["user"] = "user";
    Scope["group"] = "group";
    Scope["both"] = "both";
})(Scope = exports.Scope || (exports.Scope = {}));
var TriggerType;
(function (TriggerType) {
    TriggerType["at"] = "at";
    TriggerType["noAt"] = "noAt";
    TriggerType["both"] = "both";
})(TriggerType = exports.TriggerType || (exports.TriggerType = {}));
var TriggerScope;
(function (TriggerScope) {
    TriggerScope[TriggerScope["all"] = 7] = "all";
    TriggerScope[TriggerScope["owner"] = 4] = "owner";
    TriggerScope[TriggerScope["admin"] = 2] = "admin";
    TriggerScope[TriggerScope["member"] = 1] = "member";
})(TriggerScope = exports.TriggerScope || (exports.TriggerScope = {}));
var MessageFromType;
(function (MessageFromType) {
    MessageFromType["userFriend"] = "userFriend";
    MessageFromType["userGroup"] = "userGroup";
    MessageFromType["userOther"] = "userOther";
    MessageFromType["qqGroupNormal"] = "qqGroupNormal";
    MessageFromType["qqGroupAnonymous"] = "qqGroupAnonymous";
    MessageFromType["unknown"] = "unknown";
})(MessageFromType = exports.MessageFromType || (exports.MessageFromType = {}));
class Command {
    constructor() {
        if (this.directive)
            utils_1.assertType(this.directive, 'function');
        if (this.parse)
            utils_1.assertType(this.parse, 'function');
        if (!this.directive && !this.parse)
            throw new Error('请为Command的继承类提供directive函数或parse函数');
        const hasUserHandler = utils_1.getType(this.user) === 'function';
        const hasGroupHandler = utils_1.getType(this.group) === 'function';
        const hasBothHandler = utils_1.getType(this.both) === 'function';
        if (hasBothHandler)
            this.scope = Scope.both;
        else if (hasGroupHandler && hasUserHandler)
            this.scope = Scope.both;
        else {
            if (!hasUserHandler && !hasGroupHandler)
                throw new Error('为Command的继承类提供user函数或group函数或both函数');
            if (hasGroupHandler)
                this.scope = Scope.group;
            if (hasUserHandler)
                this.scope = Scope.user;
        }
    }
    static validate(cmd) {
        if (!cmd.constructor)
            throw new Error('请继承Command类并传入实例对象');
        if (Object.getPrototypeOf(cmd.constructor) !== Command)
            throw new Error('请继承Command类并传入实例对象');
        if (cmd.parse)
            utils_1.assertType(cmd.parse, 'function');
        if (cmd.group)
            utils_1.assertType(cmd.group, 'function');
        if (cmd.user)
            utils_1.assertType(cmd.user, 'function');
        if (cmd.both)
            utils_1.assertType(cmd.both, 'function');
        if (!cmd.both && !cmd.group && !cmd.user)
            throw new Error('请至少实现一个处理函数：both、group、user');
        const defaultDirective = cmd.constructor.name + 'Default';
        if (typeof cmd.directive === 'function') {
            const directives = cmd.directive();
            if (utils_1.getType(directives) === 'array' || directives.length !== 0) {
                cmd.directives = directives;
                return;
            }
            else
                cmd.directives = [defaultDirective];
        }
        else
            cmd.directives = [defaultDirective];
    }
}
exports.Command = Command;
Command.blackList = [
    'scope',
    'directives',
    'context',
    'httpPlugin',
    'includeGroup',
    'excludeGroup',
    'includeUser',
    'excludeUser',
    'triggerType',
    'triggerScope',
];
function include(include) {
    return function (proto, name, descriptor) {
        if (name === 'group') {
            if ('excludeGroup' in proto)
                throw new Error('exclude and include decorators cannot used at the same time');
            proto.includeGroup = include;
        }
        else if (name === 'user') {
            if ('excludeUser' in proto)
                throw new Error('exclude and include decorators cannot used at the same time');
            proto.includeUser = include;
        }
        else
            logger_1.warn('include decorator only works with user or group function');
    };
}
exports.include = include;
function exclude(exclude) {
    return function (proto, name, descriptor) {
        if (name === 'group') {
            if ('includeGroup' in proto)
                throw new Error('exclude and include decorators cannot used at the same time');
            proto.excludeGroup = exclude;
        }
        else if (name === 'user') {
            if ('includeUser' in proto)
                throw new Error('exclude and include decorators cannot used at the same time');
            proto.excludeUser = exclude;
        }
        else
            console.warn('exclude decorator only works with user or group function');
    };
}
exports.exclude = exclude;
function trigger(type) {
    return function (proto, name, descriptor) {
        if (name !== 'group' && name !== 'both') {
            logger_1.warn('trigger decorator only works with group or both function.');
        }
        else
            proto.triggerType = type;
    };
}
exports.trigger = trigger;
function scope(role) {
    return function (proto, name, descriptor) {
        if (name !== 'group' && name !== 'both') {
            logger_1.warn('trigger decorator only works with group or both function.');
        }
        else
            proto.triggerScope = role;
    };
}
exports.scope = scope;
function fromUserMessage(p) {
    return CQHelper_1.CQMessageFromTypeHelper.isUserMessage(p.messageFromType);
}
exports.fromUserMessage = fromUserMessage;
function fromQQGroupMessage(p) {
    return CQHelper_1.CQMessageFromTypeHelper.isQQGroupMessage(p.messageFromType);
}
exports.fromQQGroupMessage = fromQQGroupMessage;
function fromQQGroupNormalMessage(p) {
    return CQHelper_1.CQMessageFromTypeHelper.isQQGroupNormalMessage(p.messageFromType);
}
exports.fromQQGroupNormalMessage = fromQQGroupNormalMessage;
function fromQQGroupAnonymousMessage(p) {
    return CQHelper_1.CQMessageFromTypeHelper.isQQGroupAnonymousMessage(p.messageFromType);
}
exports.fromQQGroupAnonymousMessage = fromQQGroupAnonymousMessage;
//# sourceMappingURL=Command.js.map