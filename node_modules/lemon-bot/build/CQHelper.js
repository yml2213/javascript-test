"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Command_1 = require("./Command");
class CQMessageHelper {
    static normalizeMessage(message) {
        if (typeof message === 'string') {
            throw new Error('请设置HTTP插件的配置文件的post_message_format为array');
        }
        else
            return message;
    }
    static removeAt(message) {
        return message.filter(msg => msg.type !== 'at');
    }
    static isAt(robotQQ, messages) {
        return messages.some(msg => msg.type === 'at' && +msg.data.qq === robotQQ);
    }
    static toRawMessage(messages, removeAt = false) {
        const textTypes = ['text', 'emoji', 'sface', 'face'];
        if (!removeAt)
            textTypes.push('at');
        const text = messages
            .filter(msg => textTypes.includes(msg.type))
            .map(msg => {
            if (msg.type === 'text')
                return CQMessageHelper.escapeTextMessage(msg).data.text;
            if (msg.type === 'at')
                return `[CQ:at,qq=${msg.data.qq}]`;
            if (msg.type === 'emoji')
                return `[CQ:emoji,id=${msg.data.id}]`;
            if (msg.type === 'sface')
                return `[CQ:bface,id=${msg.data.id}]`;
            if (msg.type === 'face')
                return `[CQ:face,id=${msg.data.id}]`;
        })
            .join('')
            .trim();
        return text;
    }
    static escapeTextMessage(message) {
        const map = {
            '&': '&amp;',
            '[': '&#91;',
            ']': '&#93;',
        };
        const escapedText = message.data.text
            .split('')
            .map(char => {
            if (char in map)
                return map[char];
            return char;
        })
            .join('');
        return {
            type: 'text',
            data: {
                text: escapedText,
            },
        };
    }
}
exports.CQMessageHelper = CQMessageHelper;
class CQRawMessageHelper {
    static removeAt(str) {
        const reg = /\[CQ:at,qq=\d+]/;
        return str.replace(reg, '').trim();
    }
    static isFileMessage(str) {
        const reg = /\[CQ:image,file=(.+),url=(.+)]/;
        const res = reg.exec(str);
        if (res === null)
            return {
                result: false,
            };
        return {
            result: true,
            file: res[1],
            path: res[2],
        };
    }
    static parseCQ(cqStr) {
        try {
            const sIndex = cqStr.indexOf(':');
            const eIndex = cqStr.indexOf(',');
            const func = cqStr.slice(sIndex + 1, eIndex);
            const contentStr = cqStr.slice(eIndex + 1, -1);
            const params = {};
            contentStr.split(',').map(item => {
                let [k, v] = item.split('=');
                v = v
                    .replace(/&amp;/g, '&')
                    .replace(/&#91;/g, '[')
                    .replace(/&#93;/g, ']')
                    .replace(/&#44;/g, ',');
                try {
                    v = JSON.parse(v);
                }
                catch (e) {
                }
                params[k] = v;
            });
            return {
                func,
                params,
            };
        }
        catch (e) {
            return null;
        }
    }
}
exports.CQRawMessageHelper = CQRawMessageHelper;
class CQMessageFromTypeHelper {
    static getMessageFromType({ message_type, sub_type }) {
        if (message_type === 'group' && sub_type === 'normal')
            return Command_1.MessageFromType.qqGroupNormal;
        if (message_type === 'group' && sub_type === 'anonymous')
            return Command_1.MessageFromType.qqGroupAnonymous;
        if (message_type === 'private' && sub_type === 'friend')
            return Command_1.MessageFromType.userFriend;
        if (message_type === 'private' && sub_type === 'group')
            return Command_1.MessageFromType.userGroup;
        if (message_type === 'private' && sub_type === 'other')
            return Command_1.MessageFromType.userOther;
        return Command_1.MessageFromType.unknown;
    }
    static isUserMessage(messageFromType) {
        return (messageFromType === Command_1.MessageFromType.userFriend ||
            messageFromType === Command_1.MessageFromType.userGroup ||
            messageFromType === Command_1.MessageFromType.userOther);
    }
    static isQQGroupMessage(messageFromType) {
        return (CQMessageFromTypeHelper.isQQGroupNormalMessage(messageFromType) ||
            CQMessageFromTypeHelper.isQQGroupAnonymousMessage(messageFromType));
    }
    static isQQGroupNormalMessage(messageFromType) {
        return messageFromType === Command_1.MessageFromType.qqGroupNormal;
    }
    static isQQGroupAnonymousMessage(messageFromType) {
        return messageFromType === Command_1.MessageFromType.qqGroupAnonymous;
    }
}
exports.CQMessageFromTypeHelper = CQMessageFromTypeHelper;
//# sourceMappingURL=CQHelper.js.map